C51 COMPILER V9.51   MAIN                                                                  09/19/2025 16:04:23 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE main.c BROWSE INCDIR(..\source_data;..\a) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "STC15F2K60S2.h"
   2          #include "sys.h"
   3          #include "beep.h"
   4          #include "displayer.h"
   5          #include "IR.h"
   6          #include "Key.h"
   7          #include "uart1.h"
   8          
   9          code unsigned long SysClock=11059200;         //必须。定义系统工作时钟频率(Hz)，用户必须修改成与实际工作频
             -率（下载时选择的）一致
  10          #ifdef _displayer_H_                          //显示模块选用时必须。（数码管显示译码表，用艨尚薷摹⒃黾拥
             -） 
  11          code char decode_table[]={    0x00, 0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07, 0x7f,0x6f,0x3f, 0x1E,0x6B,0x75,  
  12                            /* 序号:    0     1    2    3    4    5    6    7     8    9    10    11   12   13       */
  13                            /* 显示:    wu    1    2    3    4    5    6    7     8    9    0     J    Q    K        *
             -/  
  14                                     0x3f|0x80,0x06|0x80,0x5b|0x80,0x4f|0x80,0x66|0x80,0x6d|0x80,0x7d|0x80,0x07|0x80
             -,0x7f|0x80,0x6f|0x80 };  
  15                       /* 带小数点     0         1         2         3         4         5         6         7      
             -   8         9        */
  16          
  17          #endif
  18          
  19          unsigned char card[52] = {
  20              0x07, 0x02, 0x0c, 0x09, 0x0a, 0x0d, 0x03, 0x05, 0x08, 0x01, 0x06, 0x0b, 0x04,
  21              0x0d, 0x09, 0x02, 0x0a, 0x07, 0x0c, 0x01, 0x0b, 0x03, 0x08, 0x04, 0x06, 0x05,
  22              0x0b, 0x01, 0x0d, 0x08, 0x04, 0x0c, 0x0a, 0x07, 0x03, 0x09, 0x06, 0x02, 0x05,
  23              0x06, 0x0c, 0x04, 0x0a, 0x0d, 0x01, 0x08, 0x09, 0x0b, 0x03, 0x07, 0x02, 0x05
  24          };
  25          
  26          unsigned char txdbuf[4];//发送下位机:序号+牌
  27          unsigned char txdPC[5];//PC交流：序号+牌+比赛是否结束
  28          unsigned char rxdbuf[4]={0x01,0x01,0x01,0x01};//接收下位机:序号+牌
  29          unsigned char rxdbuf1[4];//用于存储上次接收到的信息
  30          int card_number=0;//发牌序号
  31          
  32          void send_card()//发牌
  33          {
  34   1        int i=1;
  35   1        char Key1 = GetKeyAct(enumKey1);
  36   1        char Key2 = GetKeyAct(enumKey2);
  37   1        char Key3 = GetKeyAct(enumKey3);
  38   1        
  39   1        if (Key1 == enumKeyPress) 
  40   1        {
  41   2          txdbuf[0]=0x01;
  42   2          for(;i<4;i++)
  43   2          {//判断上次该位置是否未出牌
  44   3            if(rxdbuf[i]!=0x00)//出过牌
  45   3            {
  46   4              if(card_number<52)
  47   4              {
  48   5                txdbuf[i]=card[card_number];
  49   5                card_number=card_number+1;
  50   5              }
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 16:04:23 PAGE 2   

  51   4              else //没有牌，比赛结束
  52   4              {
  53   5                txdPC[0]=0x01;
  54   5                txdPC[1]=0x01;txdPC[2]=0x01;txdPC[3]=0x01;
  55   5                txdPC[4]=0x01;
  56   5                Uart1Print(txdPC,sizeof(txdPC));
  57   5              }
  58   4            }
  59   3            else//未出牌
  60   3            {
  61   4              txdbuf[i]=0x00;
  62   4            }
  63   3          }
  64   2          IrPrint(txdbuf,sizeof(txdbuf));
  65   2          SetBeep(5600,30);
  66   2        }
  67   1        
  68   1        if (Key2 == enumKeyPress) 
  69   1        {
  70   2          txdbuf[0]=0x02;
  71   2          for(;i<4;i++)
  72   2          {
  73   3            if(rxdbuf[i]!=0x00)
  74   3            {
  75   4              if(card_number<52)
  76   4              {
  77   5                txdbuf[i]=card[card_number];
  78   5                card_number++;
  79   5              }
  80   4              else //没有牌，比赛结束
  81   4              {
  82   5                txdPC[0]=0x00;
  83   5                txdPC[1]=0x0a;txdPC[2]=0x0b;txdPC[3]=0x0c;
  84   5                txdPC[4]=0x01;
  85   5                Uart1Print(txdPC,sizeof(txdPC));
  86   5              }
  87   4            }
  88   3            else
  89   3            {
  90   4              txdbuf[i]=0x00;
  91   4            }
  92   3          }
  93   2          IrPrint(txdbuf,sizeof(txdbuf));
  94   2          SetBeep(5600,30);
  95   2        }
  96   1      
  97   1        if (Key3 == enumKeyPress) 
  98   1        {//再次发送上次相同的信息，用于排除错误信息
  99   2          IrPrint(txdbuf,sizeof(txdbuf));
 100   2          SetBeep(5600,30);
 101   2        }
 102   1      
 103   1      }
 104          
 105          void send_PC()//接收出牌，上位机通信
 106          {
 107   1        int i=0;
 108   1        if(rxdbuf1[0]==rxdbuf[0]&&rxdbuf1[1]==rxdbuf[1]&&rxdbuf1[2]==rxdbuf[2]&&rxdbuf1[3]==rxdbuf[3])
 109   1        { 
 110   2          SetBeep(7200,100);
 111   2          txdPC[0]=rxdbuf[0];
 112   2          txdPC[1]=rxdbuf[1];
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 16:04:23 PAGE 3   

 113   2          txdPC[2]=rxdbuf[2];
 114   2          txdPC[3]=rxdbuf[3];
 115   2          txdPC[4]=0x00;
 116   2          Uart1Print(txdPC,sizeof(txdPC));
 117   2      
 118   2        }
 119   1        for(;i<4;i++)
 120   1        {
 121   2          rxdbuf1[i]=rxdbuf[i];
 122   2        }
 123   1      }
 124          
 125          void main() 
 126          { 
 127   1        IrInit(NEC_R05d);
 128   1        DisplayerInit();
 129   1        KeyInit();
 130   1        BeepInit();
 131   1        Uart1Init(2400);
 132   1        
 133   1        SetDisplayerArea(0,7);
 134   1        Seg7Print(2,0,0,0,0,0,0,0);
 135   1        LedPrint(0xff);
 136   1        
 137   1        SetIrRxd(rxdbuf,sizeof(rxdbuf));
 138   1        SetEventCallBack(enumEventKey,send_card);
 139   1        SetEventCallBack(enumEventIrRxd,send_PC);
 140   1        
 141   1        MySTC_Init(); 
 142   1        while(1)              
 143   1          { MySTC_OS();    
 144   2          }              
 145   1      }   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    530    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     71       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
